####题目描述
今天介绍的是LeetCode算法题中Easy级别的第239题（顺位题号是1010）。在歌曲列表中，第i首歌曲的持续时间为[i]秒。

返回其总持续时间（以秒为单位）可被60整除的歌曲对的数量，即当i <j时，(time[i] + time[j])％60 == 0。

例如：

输入：[30,20,150,100,40]
输出：3
说明：三对总持续时间可被60整除：
(time[0] = 30，time[2] = 150)：总持续时间180
(time[1] = 20，time[3] = 100)：总持续时间120
(time[1] = 20，time[4] = 40)：总持续时间60

输入：[60,60,60]
输出：3
说明：所有三对的总持续时间为120，可被60整除。

注意：

1 <= time.length <= 60000

1 <= time[i] <= 500



##############思路分析
##### 我们需要将时间复杂度降到O(N)，就得重新考虑time中的元素值特性。

例如[30,20,150,100,40]，其中30和150可以配对，20和100可以配对，20和40可以配对，这三对数之和都可以被60整除，那我们可以事先就将这些数简化一步，对60取余，得到[30,20,30,40,40]，
新的数范围是[0,59]，那么只要后面出现的数能在前面找到一个数，两者互补（即两者之和等于60的倍数），即60-temp = temp2; temp2在temp的后面出现，变成伪代码就是60-time[i]%60。

但是换到另外一个例子上来看，[60,60,60]，取余后变成了[0,0,0]，再用60去减，发现没有可以配对的数，那我们就再取余一次，即(60-time[i]%60)%60，这样就可以处理那些本身是60的倍数的数。

思路：先对time中的数用60进行取余运算，使用一个HashMap，key为新数组的元素值，value为出现次数，遍历新数组中的元素num，找到(60-num)%60在HashMap中的value值，进行累加，最后输出。
下面将HashMap换成了int数组



def numPairsDivisibleBy60(self, time: List[int]) -> int:
        counter = [0]*60
        res = 0
        for i in time:
            i = i % 60
            res += counter[(60-i)%60]       ####找到两者互补（即两者之和等于60的倍数），即60-temp = temp2的数
            counter[i]+=1
        return res
