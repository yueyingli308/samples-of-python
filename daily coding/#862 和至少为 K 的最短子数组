对于子数组之和的问题，十有八九是要建立累加和数组的，因为其可以快速的计算任意区间和，但即便是有了累加和数组，遍历所有区间和还是会超时。
用累加数组计算任意区间 [i, j] 的累加和是用 [0, j] 区间和减去 [0, i-1] 区间和得到的，只有两个区间和差值大于等于K的时候，才会更新结果，
所有小于K的区间差是不需要计算的。这样的话，假如能使得所有区间和按照从小到大的顺序排列，那么当前区间和按顺序减去队列中的区间和，一旦差值小于K了，后面的区间和就不用再检验了，
这样就可以节省很多运算。

----------- 
问题描述：
和至少为 K 的最短子数组

返回 A 的最短的非空连续子数组的长度，该子数组的和至少为 K 。
如果没有和至少为 K 的非空子数组，返回 -1 。

示例 1：

输入：A = [1], K = 1
输出：1
示例 2：

输入：A = [1,2], K = 4
输出：-1

————————————————
版权声明：本文为CSDN博主「GrowthDiary007」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/XX_123_1_RJ/article/details/80954473
def shortestSubarray(self, A, K):
 
      n, dp = len(A), [0]  # 初始化dp[i] = A[0]+A[1]+...+A[i-1]
      for v in A: dp.append(dp[-1] + v)

      queue, res = collections.deque(), n + 1  # 初始化队列、结果变量
      for i in range(n+1):
          while queue and dp[i] <= dp[queue[-1]]:
              queue.pop()  # 出队, 删除不符合的

          while queue and dp[i] - dp[queue[0]] >= K:
              res = min(res, i - queue.popleft())  # 从左边出队，并更新最短距离。

          queue.append(i)  # 入队

      return res if res < n + 1 else -1  #返回最优解

       
分析：

显然，我们会想到使用dp[i]记录sum(A[:i])，那么这道题就变成了，给定一个数组dp,找到一组i,j，使得dp[j]-dp[i]>=K，且j-i尽量小！
数据长度达到50000，显然不能使用O(n^2)复杂度的方法，我们得想办法让i,j只走一遍
用一个简单的示例来分析，设 A = [4,-1,2,3],，K = 5，那么dp = [0,4,3,5,8]，我们从dp数组的第2个数开始分析，
（假设来了个-1，那么因为-1比0小，后面任意一个数val如若满足val-0>K,那么val+1也一定大于K，且-1所在的位置i显然能获得更优解，所以0这个位置就失去了意义），

现在考虑示例，来了个4，我们发现4-0小于5，我们怎么对4进行处理呢，因为考虑到之后或许会出现一个足够大的数，比如9，那么4相对于0是更优的，但也有可能只来一个8，那么4就没作用了，
所以先暂且保留观察。等到来了一个5以上的数，我们依次对保留的数（目前是0，4）进行判断得最优解。
接下来来了个3，那么根据上面提到的论点，4将会被舍弃，但3比0要大，故此时0，3保留。
然后来了个5，5-0>=5，故找到一组i,j，记录下来，然后判断 5-3>=5 ?如若确实大于，即再次找到一组i,j，若小于，则5保留（考虑到之后或许来了个10），依次类推
思路：

建立一个队列记录保留数字，初始为0
依次对dp中的数进行分析，如果dp[i] - dp[Q[0]] >= K，则记录一次i,j
如果dp[i] < dp[Q[-1]]，则舍弃Q[-1]
————————————————
版权声明：本文为CSDN博主「负雪明烛」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/fuxuemingzhu/article/details/85112389



        
------------- 如果简单版，只有正数 --------
def shortestSubarray(self, nums: List[int], k: int) -> int:
  res = []
  for i in range(len(nums)):
      cum = 0
      j = i
      while j<len(nums):
          if cum + nums[j] <k:
              cum += nums[j]
              j += 1
          else:
              res.append(j-i+1)
              break
  return -1 if res==[] else min(res)

